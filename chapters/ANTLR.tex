ANTLR e' un parser generator che genera un parser LL top down multi linguaggio. A partire da una grammatica possiamo generare il parser nel linguaggio che vogliamo e ci genera un runtime nel linguaggio che vogliamo per fare funzionare il parser.

La roba interessante e' che ci sono un sacco di grammatiche pronte per ANTLR.

Abbiamo due modi per usare questo strumento:
\begin{itemize}
    \item Uso diretto di ANTLR, leggendo il manuale e capire come funziona per scrivere il codice python
    \item Uso mediato da Liblet, significa che il prof ha scritto un po' di codice in Liblet che serve per importare roba di Java in maniera dinamica
\end{itemize}

Nel progetto e' una delle cose che possiamo scegliere.

\section{Uso diretto di ANTLR}

La cosa principale di questo strumento e' che ci permette di specificare la grammatica context free che vogliamo usare per produrre il parser tramite file o stringa. Questa grammatica e' fatta cosi', definiamo la grammatica, poi ci sono una serie di regole di tokenizzazzione scritte in maiuscolo alla cui destra c'e' una espressione regolare. Le regole della grammatica (di parsing) iniziano in minuscolo, sono date da un simbolo di tokenizzazzione e poi si possono mettere delle costanti.
Alcuni token possono essere scartati dalla parte di parsing.

\begin{lstlisting}
    
\end{lstlisting}

Adesso il punto cruciale e' utilizzare un tool Java che generi codice Python. Lui genera 4 file:
\begin{itemize}
    \item lexer
    \item parser
    \item visitor: interfaccia che permette di visitare il tree generato dal parser
    \item listener: interfaccia
\end{itemize}

%Esempio di uso

Uso del lexer, possiamo vedere i passi del lexer, il token ci fa vedere anche i caratteri del sorgente che rappresentano il token:


Abbiamo visto un esempio piu' complesso di una grammatica di espressioni ed assegnamenti. Vediamo ora come usare il paser, tendenzialmente i parser hanno due modalita' di funzionamento:
dato che l'albero e' una struttura ricorsiva ci sono due modi per poterne fruire. Ognuno di questi nodi e' relativo ad una delle regole di parsing, i figli sono i token.
\begin{itemize}
    \item listener: ha due metodi per ogni regola, entro ed esco. Poi posso invocare un processo di visita che invoca il listener secondo l'ordine che mi aspetto.
    \item visitor: me lo scrivo io, mi scrivo una funzione per ciascuna regola che sono quelle usate per fare la visita.
\end{itemize}

Quello che faremo noi a lezione e' usare visitor, perche' a lezione usando LIBLET ci dara' un albero e noi ci scriveremo sempre le visite dell'albero.
Cosi' e' come useremo il listener, creo una classe che implementa il listener, poi creo l'istanza e lo passo al walker di liblet che lo usa per fare la visita:
\begin{lstlisting}

\end{lstlisting}

Nel caso del visitor ho sempre la mia classe che implementa il vistor, mi implemento dentro la visita e poi uso la classe per fare la visita che mi sono scritto:
\begin{lstlisting}

\end{lstlisting}

Fino ad ora non ci siamo mai occupati degli errori, ma in caso di ANTLR si possono specificare degli ascoltatori di errore che hanno un metodo che va invocato ogni volta che lui vede un errore nel lexing o nel parser:
\begin{lstlisting}

\end{lstlisting}

\section{Uso mediato da Liblet}
Il modulo ANTLR dentro Liblet ci permette di prendere una grammatica e mi da un oggetto che ha delle competenze.
In questa grammatica ci sono delle etichette di ANTLR che ci servono a distinguere le alternative di una regola che ha delle alternative che e' comodo perche' se avviene un match di stat non sapremmo cosa abbiamo matchato:
\begin{lstlisting}

\end{lstlisting}

Dato l'oggetto possiamo fargli fare diverse cose, inizialmente vediamo i tokens, basta un metodo in questo caso:
\begin{lstlisting}

\end{lstlisting}

Posso avere anche il contesto, che mi da dove partire per il visitor, posso dargli anche il token da cui partire:
\begin{lstlisting}


\end{lstlisting}

L'albero di parsing possiamo produrlo con un metodo tree che produce un tree di liblet con dentro le espressioni:
\begin{lstlisting}

\end{lstlisting}

ANTLR accetta anche grammatiche malate (ricorsivita', precedenze...) c'e' pero' una malattia che non puo' essere riconosciuta a tempo di analisi, la ambiguita'. Si puo' accendere una spia che ci dice se il parsing e' ambiguo, il suggerimento e' che quando si progetta una nuova grammatica si preparano dei testcase e vedo se il diagnostici mi dice se e' la grammatica e' ambigua. Va acceso il diag = True nel context:
\begin{lstlisting}

\end{lstlisting}

%manca tutta la prima parte della lezione 16, sono arrivato tardi

\subsection{Grammatiche note}
Possiamo guardare alcune grammatiche note che possono essere utili, ad esempio c'e' una grammatica per l'aritmetica, bella ma l'associativita' a destra la sbaglia.
Un'altra grammatica carina e CALCULATOR, che parsa le espressioni e permette l'invocazione di funzioni, come il seno o coseno.

Un'altra grammatica super utile, che non viene dal repository standard, ma dal libro di antlr e' la grammatica del linguaggio Cymbol che e' una specie di linguaggetto di programmazione che ha l'invocazione a funzione e gli statement.

La fine di questa cosa e' che e' molto potente, e se incontriamo errori guardiamo in documentazione perche' ci sono alcune porcherie.

\subsection{Ancora su listener e visitor}
Ora ci assegniamo due compiti ed useremo listener e visitor per fare due cose diverse:
\begin{itemize}
    \item Numerare le righe
    \item Interpretare un linguaggio
\end{itemize}

Il linguaggio a cui faremo riferimento e' il linguaggio aritmetico con nomi di variabili ed assegnamenti. Una sequenza lineare di istruzioni in cui le istruzioni sono assegnamenti, stampe o espressioni.

%grammatica e programma

Vogliamo contare gli assegnamenti, lo faremo con un listener, sappiamo che ANTLR ci da' un listener che e' un interfaccia da estendere, noi lo estendiamo e implementiamo i metodi che ci interessano. In questo caso ci interessa il numero di assegnamenti, quindi implementiamo il metodo che ci interessa. Poi creiamo un oggetto del listener e lo passiamo al walker di liblet.

\begin{lstlisting}

\end{lstlisting}

Ora vogliamo interpretare il programma, un compito cosi' sofisiticato spesso si realizza piu' facilmente con un visitor, perche' quando scrivo un linguaggio ho in testa per ogni nodo del linguaggio cosa voglio fare, in particolare noi vogliamo che per ogni nodo restituisca il valore del nodo, questo lo puo' fare facilmente se fa una visita in post-ordine conoscendo i valori dei figli.

In questo caso abbiamo solo variabili locali, quindi la cosa piu' facile da fare e' tenere una memoria che e' un dizionario di python, se vediamo un assegnamento prendiamo il nome della variabile, facciamo lo scarico ricorsivo chiamando expr e salviamo tutto in memoria. Se vediamo una variabile, facciamo un lookup in memoria e restituiamo il valore. Se vediamo un numero lo restituiamo direttamente, da notare che quando restituiamo l'intero e' l'unico passo interpretativo perche' stiamo trasformando testo in intero. Abbiamo un espressione che fa la print, non ritorna niente ma fa una print. Dopo di che c'e' la parte di associazione, di nuovo sono divise perche' sono cose divise, in ogni caso visito tramite scarico ricorsivo il lato sinistro e destro e poi guardo il tipo dell'operatore, la visita delle parentesi e' un trucco sintattico che serve ad indicare diverse precedenze, quindi dal punto di vista interpretativo non serve a niente e si puo' solo mangiare.
%perche' due metodi per la somma e la moltiplicazione? 
\begin{lstlisting}

\end{lstlisting}

Estendere questo parser su linguaggi piu' difficili e' immediato, la logica e' sempre la stessa, basta estendere le regole di parsing e le regole di interpretazione. Potrebbe essere un buon esempio. Il trucco cruciale e' che il visitatore e' ricorsivo quindi posso quando ho un dubbio su che cosa fare posso usare la ricorsione, per valutare un espressione valuto ricorsivamente i figli e poi faccio l'operazione.
Il problema di questa cosa e' che la pila di chiamate ricorsive puo' esplodere e non e' facile da tenere sotto controllo, soprattutto se vogliamo dare degli errori durante il parsing. Quindi abbiamo bisogno di fare una traduzione in cui rendo la ricorsione esplicita, significa liberarsi della ricorsione passando ad una struttura iterativa, significa avere una pila di chiamate esplicita invece della pila di record di attivazione, l'idea qui e' che tengo dei risultati parziali. Qui dobbiamo scegliere tra visitor che usa la ricorsione e listener in cui teniamo una pila esplicita per le chiamate.

L'idea in questo caso e' di tenere gli operandi sulla pila e quando siamo pronti a fare l'operazione togliamo gli operandi e mettiamo il risultato intermedio.
Quindi il listener avra' due strutture dati per funzionare, una memoria per le variabili ed una pila. Qui ho bisogno degli exit perche' voglio sapere cosa fare con quello che c'e' sulla pila dopo che ho guardato i figli. Se usciamo da un assegnamento significa che ho gia' valutato l'espressione e sulla pila c'e' il valore da assegnare, quindi assegniamo in memoria. Se usciamo da un id o un intero significa che valutiamo il valore e mettiamo sulla pila il valore. Quando usicamo da una divisione mi aspetto che i valori dei suoi operandi siano sulla pila messi dalla visita in post-ordine, quindi li tolgo dalla pila e metto il risultato della divisione sulla pila. Se usciamo da una somma invece mettiamo il risultato della somma sulla pila.

\begin{lstlisting}

\end{lstlisting}

\section{Dall'albero di parsing all'AST}
L'idea e' di partire da un albero di parsing che ha tanti artefatti, toglierli e raggiungere una forma compatta che e' un abstract syntax tree. Per farlo usiamo una funzione ricorsiva.

Abbiamo visto che in ANTLR si puo' mettere del codice direttamente nella grammatica, non lo faremo mai e' troppo doloroso, poi non ha troppo senso tenere legata la grammatica con l'implementazione del parser.

\subsection{Dispatch table}
Useremo una dispatch table per capire cosa fare quando troviamo una regola (nella table ci saranno le funzioni ricorsive). Inizialmente diciamoche quando troviamo una regola e c'e' nella dispatch table chiamo la sua regola, se non la trovo metto tutti in un catchall:
\begin{lstlisting}
    
\end{lstlisting}

Devo riempire la tabella, in questo caso definiamo le funzioni che ci servono quando vediamo gli operatori, da notare che come scarico ricorsivo non usano se stesse ma chiamano la funzione che usa la dispatch table, poi popolo la table:
\begin{lstlisting}
    
\end{lstlisting}

Si e' visto che liblet implementa una classe TreeWalker che fa questo lavoro della funzione ricorsiva, possiamo dirgli dato un albero che attributo considerare, registrare delle funzioni che usa quando incontra dei simboli (con un annotazione o registrarle esplicitamente), inoltre permette anche di avere un catchall (ne esistono di tanti tipi).

Vediamo un esempio in cui eseguiamo il programma partendo da un ATS, notiamo che occupandoci degli atomi abbiamo solo const e var, non abbiamo bisogno di castare ad Int perche' lo abbiamo gia' fatto nella costruzione dell ATS quando mettevamo dentro il valore di una costante.

\begin{lstlisting}
    
\end{lstlisting}

\section{Trasformare}
Vediamo alcuni esperimenti di trasformazione, in particolare inizialmente vogliamo trasformare un documento JSON in un documento HTML usando ANTLR.

Quello che facciamo noi e' modularizzare il processo, partiamo generando l'AST, si fa con un tree walker ricorsivo che ha la tabella di dispatch che discrimina i nodi in base al nome.

\subsection{Trasformare HTML in matrici}
L'idea e' che ho acceduto ad una pagina HTML con dentro delle tabelle e io voglio farmi una matrice che rappresenta i dati, e' una trasformazione di dominio.

Per farlo partiamo con il definirci una nostra grammatica invece di usare quella completa assumendo per semplicita' che dentro i td possano esserci solo interi.

Il processo e' sempre lo stesso, arriviamo all'AST e qui la cosa che cambia e' che per fare la trasformazione usiamo una struttura dati esterna, uno stack, quando vediamo i dati li pushiamo dentro lo stack e quando vediamo una row togliamo i figli e li mettiamo dentro un array, alla fine dello stack avremo un array di array che rappresenta la matrice.

Abbiamo visto anche che per costruire la tabella potremmo pensare di decorare i nodi con il numero di riga e colonna mettendo nella radice il numero di righe e colonne, cosi' posso poi precomputare una matrice di dimensioni fisse piena di None e poi riempirla visitando l'AST.